19.1	Show understanding of linear and binary searching methods
19.1	Write an algorithm to implement a linear search
19.1	Write an algorithm to implement a binary search
19.1	The conditions necessary for the use of a binary search
19.1	Show understanding of insertion sort and bubble sort methods
19.1	Write an algorithm to implement an insertion sort
19.1	Write an algorithm to implement a bubble sort
19.1	Performance of a sorting routine may depend on the initial order of the data and the number of data items
19.1	Show understanding of and use Abstract Data Types (ADT)
19.1	Write algorithms to find an item in each of the following: linked list, binary tree
19.1	Write algorithms to insert an item into each of the following: stack, queue, linked list, binary tree
19.1	Write algorithms to delete an item from each of the following: stack, queue, linked list
19.1	Show understanding that a graph is an example of an ADT. Describe the key features of a graph and justify its use for a given situation
19.1	Candidates will not be required to write code for this structure.
19.1	Show how it is possible for ADTs to be implemented from another ADT
19.1	Describe the following ADTs and demonstrate how they can be implemented from appropriate built-in types or other ADTs: stack, queue, linked list, dictionary, binary tree
19.1	Show understanding that different algorithms which perform the same task can be compared by using criteria (e.g. time taken to complete the task and memory used)
19.1	Including use of Big O notation to specify time and space complexity
19.2	Show understanding of recursion
19.2	Essential features of recursion.
19.2	How recursion is expressed in a programming language.
19.2	Write and trace recursive algorithms
19.2	When the use of recursion is beneficial
19.2	Show awareness of what a compiler has to do to translate recursive programming code
19.2	Use of stacks and unwinding
19.2	20  Further Programming
20.1	Understanding what is meant by a programming paradigm
20.1	Show understanding of the characteristics of a number of programming paradigms
20.1	low-level
20.1	understanding of and ability to write low-level code that uses various addressing modes: immediate, direct, indirect, indexed and relative
20.1	Imperative (Procedural)
20.1	Assumed knowledge and understanding of Structural Programming (see details in AS content section 11.3)
20.1	understanding of and ability to write imperative (procedural) programming code that uses variabes, constructs, procedures and functions. See details in AS Content
20.1	Object Oriented
20.1	• understanding of the terminology associated with OOP (including objects, properties, methods, classes, inheritance, polymorphism, containment (aggregation), encapsulation, getters, setters, instances)
20.1	• understanding of how to solve a problem by designing appropriate classes
20.1	understanding of and ability to write code that demonstrates the use of OOP
20.1	Declarative
20.1	• understanding of and ability to solve a problem by writing appropriate facts and rules based on supplied information
20.1	• understanding of and ability to write code that can satisfy a goal using facts and rules
20.2	Write code to perform file-processing operations
20.2	Open (in read, write, append mode) and close a file
20.2	Read a record from a file and write a record to a file Perform file-processing operations on serial, sequential, random files
20.2	Show understanding of an exception and the importance of exception handling
20.2	Know when it is appropriate to use exception handling Write program code to use exception handling